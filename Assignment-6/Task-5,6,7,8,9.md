## ✅ 5. Configure Liveness & Readiness Probes

### 🔹 What Are Probes?

- **Liveness Probe**: Checks if the container is alive. If it fails, Kubernetes restarts the container.
- **Readiness Probe**: Checks if the container is ready to accept traffic. If it fails, the pod is removed from the service load balancer.

### 🧪 Use Case
Ensures zero-downtime deployments and automatically recovers unhealthy containers.

### 🛠 CLI Steps

```bash
kubectl run probe-demo \
  --image=nginx \
  --port=80 \
  --dry-run=client -o yaml > probe-demo.yaml
kubectl edit pod probe-demo
```

Add:
```yaml
livenessProbe:
  httpGet:
    path: /
    port: 80
  initialDelaySeconds: 10
  periodSeconds: 5
readinessProbe:
  httpGet:
    path: /
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 5
```

---

## ✅ 6. Taints & Tolerations

### 🔹 What Are Taints & Tolerations?

- **Taints**: Applied to nodes to repel certain pods.
- **Tolerations**: Allow specific pods to run on tainted nodes.

Together, they control pod placement more precisely than labels.

### 🧪 Use Case
Used to dedicate nodes for specific workloads like GPU-based pods or system components.

### 🛠 CLI Steps

Taint a node:
```bash
kubectl get nodes
kubectl taint nodes <node-name> key=value:NoSchedule
```

Run a tolerating pod:
```bash
kubectl run toleration-pod \
  --image=nginx \
  --overrides='
{
  "apiVersion": "v1",
  "spec": {
    "tolerations": [
      {
        "key": "key",
        "operator": "Equal",
        "value": "value",
        "effect": "NoSchedule"
      }
    ]
  }
}' --dry-run=client -o yaml | kubectl apply -f -
```

---

## ✅ 7. Create and Attach PVC to Pods

### 🔹 What is a Persistent Volume Claim?

- **PVC**: A request for storage by a user.
- **PV**: A piece of storage in the cluster, either statically or dynamically provisioned.

PVCs decouple storage provisioning from pod lifecycle.

### 🧪 Use Case
Used when apps need to store data persistently (e.g., databases, logs).

### 🛠 CLI Steps

Create a PVC:
```bash
kubectl create pvc pvc-demo \
  --storage=1Gi \
  --access-modes=ReadWriteOnce \
  --storage-class=managed-premium
```

Attach to a pod:
```bash
kubectl run pvc-pod --image=nginx --restart=Never --overrides='
{
  "apiVersion": "v1",
  "spec": {
    "volumes": [
      {
        "name": "mypvc",
        "persistentVolumeClaim": {
          "claimName": "pvc-demo"
        }
      }
    ],
    "containers": [
      {
        "name": "nginx",
        "image": "nginx",
        "volumeMounts": [
          {
            "mountPath": "/usr/share/nginx/html",
            "name": "mypvc"
          }
        ]
      }
    ]
  }
}' -o yaml | kubectl apply -f -
```

---

## ✅ 8. Configure Health Probes (Deployment Patching)

### 🔹 Why Health Probes?

They allow Kubernetes to monitor and act upon the health of the containers:
- **Liveness Probe**: Restart dead containers.
- **Readiness Probe**: Control traffic flow to containers.

### 🧪 Use Case
Useful for apps that might hang or take time to become ready after a restart.

### 🛠 CLI Steps

Patch an existing deployment:
```bash
kubectl patch deployment <your-deployment> --type='json' -p='[
  {
    "op": "add",
    "path": "/spec/template/spec/containers/0/livenessProbe",
    "value": {
      "httpGet": {
        "path": "/",
        "port": 80
      },
      "initialDelaySeconds": 10,
      "periodSeconds": 5
    }
  },
  {
    "op": "add",
    "path": "/spec/template/spec/containers/0/readinessProbe",
    "value": {
      "httpGet": {
        "path": "/",
        "port": 80
      },
      "initialDelaySeconds": 5,
      "periodSeconds": 5
    }
  }
]'
```

---

## ✅ 9. Horizontal Pod Autoscaler (HPA)

### 🔹 What is HPA?

- Automatically scales the number of pods in a deployment based on CPU/memory usage.
- Keeps workloads responsive and efficient.

### 🧪 Use Case
Handles unpredictable or spiky workloads, ensuring apps remain performant.

### 🛠 CLI Steps

Deploy app:
```bash
kubectl create deployment autoscale-demo --image=nginx
kubectl expose deployment autoscale-demo --port=80 --target-port=80
```

Set resource limits:
```bash
kubectl set resources deployment autoscale-demo --limits=cpu=500m --requests=cpu=200m
```

Enable autoscaling:
```bash
kubectl autoscale deployment autoscale-demo --cpu-percent=50 --min=1 --max=5
```

Check HPA:
```bash
kubectl get hpa
```

---

## 📘 References

- Azure AKS Docs: https://learn.microsoft.com/en-us/azure/aks/
- YouTube Tutorials:
  - [Scaling Kubernetes](https://www.youtube.com/watch?v=BUAFNfdarBQ)
  - [Node Maintenance in AKS](https://www.youtube.com/watch?v=soLCemusoE8)
  - [Persistent Volumes in AKS](https://www.youtube.com/watch?v=JD3mj5bTOuk)
  - [Health Probes](https://www.youtube.com/watch?v=XJB1RO32HVo&t=2978s)
  - [Autoscaling](https://www.youtube.com/watch?v=6TZsd4toIbg)

---

> 📝 Replace `<node-name>` and `<your-deployment>` with actual names from your cluster environment.


